{"ast":null,"code":"import { Node, mergeAttributes, isNodeSelection, nodeInputRule } from '@tiptap/core';\nimport { TextSelection, NodeSelection } from '@tiptap/pm/state';\n\n/**\n * This extension allows you to insert horizontal rules.\n * @see https://www.tiptap.dev/api/nodes/horizontal-rule\n */\nconst HorizontalRule = Node.create({\n  name: 'horizontalRule',\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  group: 'block',\n  parseHTML() {\n    return [{\n      tag: 'hr'\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({\n        chain,\n        state\n      }) => {\n        const {\n          selection\n        } = state;\n        const {\n          $from: $originFrom,\n          $to: $originTo\n        } = selection;\n        const currentChain = chain();\n        if ($originFrom.parentOffset === 0) {\n          currentChain.insertContentAt({\n            from: Math.max($originFrom.pos - 1, 0),\n            to: $originTo.pos\n          }, {\n            type: this.name\n          });\n        } else if (isNodeSelection(selection)) {\n          currentChain.insertContentAt($originTo.pos, {\n            type: this.name\n          });\n        } else {\n          currentChain.insertContent({\n            type: this.name\n          });\n        }\n        return currentChain\n        // set cursor after horizontal rule\n        .command(({\n          tr,\n          dispatch\n        }) => {\n          var _a;\n          if (dispatch) {\n            const {\n              $to\n            } = tr.selection;\n            const posAfter = $to.end();\n            if ($to.nodeAfter) {\n              if ($to.nodeAfter.isTextblock) {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1));\n              } else if ($to.nodeAfter.isBlock) {\n                tr.setSelection(NodeSelection.create(tr.doc, $to.pos));\n              } else {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos));\n              }\n            } else {\n              // add node after horizontal rule if it’s the end of the document\n              const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\n              if (node) {\n                tr.insert(posAfter, node);\n                tr.setSelection(TextSelection.create(tr.doc, posAfter + 1));\n              }\n            }\n            tr.scrollIntoView();\n          }\n          return true;\n        }).run();\n      }\n    };\n  },\n  addInputRules() {\n    return [nodeInputRule({\n      find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n      type: this.type\n    })];\n  }\n});\nexport { HorizontalRule, HorizontalRule as default };","map":{"version":3,"names":["HorizontalRule","Node","create","name","addOptions","HTMLAttributes","group","parseHTML","tag","renderHTML","mergeAttributes","options","addCommands","setHorizontalRule","chain","state","selection","$from","$originFrom","$to","$originTo","currentChain","parentOffset","insertContentAt","from","Math","max","pos","to","type","isNodeSelection","insertContent","command","tr","dispatch","posAfter","end","nodeAfter","isTextblock","setSelection","TextSelection","doc","isBlock","NodeSelection","node","_a","parent","contentMatch","defaultType","insert","scrollIntoView","run","addInputRules","nodeInputRule","find"],"sources":["../src/horizontal-rule.ts"],"sourcesContent":["import {\n  isNodeSelection, mergeAttributes, Node, nodeInputRule,\n} from '@tiptap/core'\nimport { NodeSelection, TextSelection } from '@tiptap/pm/state'\n\nexport interface HorizontalRuleOptions {\n  /**\n   * The HTML attributes for a horizontal rule node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       * @example editor.commands.setHorizontalRule()\n       */\n      setHorizontalRule: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to insert horizontal rules.\n * @see https://www.tiptap.dev/api/nodes/horizontal-rule\n */\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [{ tag: 'hr' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule:\n        () => ({ chain, state }) => {\n          const { selection } = state\n          const { $from: $originFrom, $to: $originTo } = selection\n\n          const currentChain = chain()\n\n          if ($originFrom.parentOffset === 0) {\n            currentChain.insertContentAt(\n              {\n                from: Math.max($originFrom.pos - 1, 0),\n                to: $originTo.pos,\n              },\n              {\n                type: this.name,\n              },\n            )\n          } else if (isNodeSelection(selection)) {\n            currentChain.insertContentAt($originTo.pos, {\n              type: this.name,\n            })\n          } else {\n            currentChain.insertContent({ type: this.name })\n          }\n\n          return (\n            currentChain\n              // set cursor after horizontal rule\n              .command(({ tr, dispatch }) => {\n                if (dispatch) {\n                  const { $to } = tr.selection\n                  const posAfter = $to.end()\n\n                  if ($to.nodeAfter) {\n                    if ($to.nodeAfter.isTextblock) {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1))\n                    } else if ($to.nodeAfter.isBlock) {\n                      tr.setSelection(NodeSelection.create(tr.doc, $to.pos))\n                    } else {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos))\n                    }\n                  } else {\n                    // add node after horizontal rule if it’s the end of the document\n                    const node = $to.parent.type.contentMatch.defaultType?.create()\n\n                    if (node) {\n                      tr.insert(posAfter, node)\n                      tr.setSelection(TextSelection.create(tr.doc, posAfter + 1))\n                    }\n                  }\n\n                  tr.scrollIntoView()\n                }\n\n                return true\n              })\n              .run()\n          )\n        },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule({\n        find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type,\n      }),\n    ]\n  },\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}